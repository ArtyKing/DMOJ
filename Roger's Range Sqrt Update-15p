//https://dmoj.ca/problem/oly18novp6
#include <bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f
#define LINF 0x3f3f3f3f3f3f3f3f
#define pb push_back
#define endl "\n"
#define int long long
#define TRACE(x) cerr << #x << " = " << x << endl
#define set(arr, x) memset(arr, x, sizeof(arr))
#define copy(start, dest) memcpy(dest, start, sizeof(start));
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int maxN = 1e5+1, mod = 1e9+7;
int n, q, a[maxN];


struct segT{
#define lc (idx<<1)
#define rc (idx<<1|1)
    struct Node{
        int l, r, rm, sum;
    }seg[maxN*4];
    void push_up(int idx){
        seg[idx].rm = max(seg[lc].rm, seg[rc].rm);
        seg[idx].sum = seg[lc].sum+seg[rc].sum;
    }
    void build(int l, int r, int idx){
        seg[idx].l = l; seg[idx].r = r;
        if(l == r) {
            seg[idx].sum = a[l];
            seg[idx].rm = a[l];
            return;
        }
        int mid = (l+r)/2;
        build(l, mid, lc);
        build(mid+1, r, rc);
        push_up(idx);
    }
    void update(int l, int r, int idx){
        if(seg[idx].rm <= 1) return;
        if(seg[idx].l == seg[idx].r) {
            //Update values here
            seg[idx].sum = floor(sqrt(seg[idx].sum));
            seg[idx].rm = seg[idx].sum;
            return;
        }
        int mid = (seg[idx].l + seg[idx].r) / 2;
        if( r <= mid ) update (l, r, lc);
        else if ( l > mid ) update (l, r, rc);
        else { update(l, mid, lc);  update(mid+1, r, rc); }
        push_up(idx);
    }
    int query(int l, int r, int idx){
        if(seg[idx].l == l && seg[idx].r == r) return seg[idx].sum;
        int mid = (seg[idx].l+seg[idx].r)/2;
        if(r <= mid){
            return query(l, r, lc);
        }
        else if(l > mid){
            return query(l, r, rc);
        }
        else{
            return query(l, mid, lc)+query(mid+1, r, rc);
        }
    }
}segTree;

int32_t main(void) {
    cin.tie(0)->sync_with_stdio(0);
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    segTree.build(1, n, 1);
    cin >> q;
    while(q--){
        int op, x, y; cin >> op >> x >> y;
        if(op == 1){
            //Sum
            cout << segTree.query(x, y, 1) << endl;
        }
        if(op == 2){
            //Range SQRT thing
            segTree.update(x, y, 1);
        }
    }

}
